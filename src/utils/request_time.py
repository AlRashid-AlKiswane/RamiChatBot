"""
Middleware for logging request latency and handling exceptions in a FastAPI application.

This middleware measures the time taken to process each HTTP request, logs key metrics,
and ensures that all unexpected exceptions are caught and logged appropriately.
"""

import logging
import os
import sys
import time
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse
from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR

try:
    # Setup import path
    MAIN_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../"))
    if not os.path.exists(MAIN_DIR):
        raise FileNotFoundError(f"Project directory not found at: {MAIN_DIR}")

    if MAIN_DIR not in sys.path:
        sys.path.append(MAIN_DIR)

    from src.logs import log_error, log_info

except ImportError as ie:
    logging.error("Import error during setup: %s", ie, exc_info=True)
except (ValueError, KeyError, RuntimeError) as e:
    logging.critical("Unexpected setup error: %s", e, exc_info=True)
    raise


# pylint: disable = too-few-public-methods
class RequestTimingMiddleware(BaseHTTPMiddleware):
    """
    Middleware to measure and log the processing time of each HTTP request.
    It also handles unexpected exceptions and logs them properly.
    """

    async def dispatch(self, request: Request, call_next):
        """
        Measure and log the time taken to process the request.
        Handles and logs unexpected errors gracefully.

        Args:
            request (Request): The incoming FastAPI request object.
            call_next (Callable): The next middleware or route handler.

        Returns:
            Response: The response generated by the application.
        """
        start_time = time.perf_counter()
        try:
            response = await call_next(request)
        except (RuntimeError, ValueError, KeyError) as e:
            process_time = time.perf_counter() - start_time
            log_error({
                "event": "internal_error",
                "path": request.url.path,
                "latency_seconds": round(process_time, 4),
                "error": str(e)
            })
            return JSONResponse(
                status_code=HTTP_500_INTERNAL_SERVER_ERROR,
                content={"detail": "Internal Server Error"}
            )

        process_time = time.perf_counter() - start_time
        log_info({
            "event": "request_metrics",
            "path": request.url.path,
            "latency_seconds": round(process_time, 4),
            "status_code": response.status_code
        })

        return response
